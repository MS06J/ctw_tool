import os
import json
import string
import time
import numpy as np
import pandas as pd
import statistics as stat
import scipy.signal as sig
import scipy.fft as fft
from xlsx2csv import Xlsx2csv
from io import StringIO

'''
This library extract can handle json and excel file generated by CTW Probe. Some simple and frequent signal precessing tool are also included.
Arthur:Hsu,Wen-Shuo
'''

class ctw_data:
    def __init__(self, path: string):
        self.path=path
        self.RodForce=0
        self.Force=list()
        self.Temperature=list()
        self.Displacement=list()
        self.DisplacementCommand=list()
        self.Velocity=list()
        self.GeneratedVelocity=list()
        self.Time=list()

    def extract_ctw_json(self):
        '''
        Extract RodForce/Force/Temperature/Displacement/DisplacementCommand/Velocity/GeneratedVelocity/Time data
        fron CTW Probe generated .json files.
        Output is a dictionary, containg one float (RodForce) and other seven data in list.
        '''
        with open(self.path, 'r') as f:
            j_data=json.loads(f.read().strip('[').strip(']'))
        temp_Signals=dict()
        for i in range(len(j_data['Signals'])):
            temp_Signals[j_data['Signals'][0]['Name']]=j_data['Signals'][0]['Data']
            j_data['Signals'].pop(0)
        temp_Signals[j_data['Constants'][4]['Name']]=j_data['Constants'][4]['Value']
        j_data=temp_Signals
        return j_data

    def extract_ctw_excel(self,print_run_time=False):
        '''
        Extract RodForce/Force/Temperature/Displacement/DisplacementCommand/Velocity/GeneratedVelocity/Time data
        fron CTW Probe generated .xlsx files.
        This function does not have output, all data is stored as list inside Objects' attributes.
        print_run_time is for programs speed diagnose.
        Large excel file with many points may take up to 3 sec to read.
        '''
        if print_run_time:
            start_time=time.time()
        if False:
            buffer = StringIO()
            Xlsx2csv(self.path, outputencoding="utf-8").convert(buffer)
            buffer.seek(0)
            data=pd.read_csv(buffer)
            buffer.close()
            data=pd.read_csv(self.path)
        data=pd.read_excel(self.path)
        self.RodForce=data.iloc[10,1]
        self.Force=data.iloc[35:,0].tolist()
        self.Temperature=data.iloc[35:,1].tolist()
        self.Displacement=data.iloc[35:,2].tolist()
        self.DisplacementCommand=data.iloc[35:,3].tolist()
        self.Velocity=data.iloc[35:,4].tolist()
        self.GeneratedVelocity=data.iloc[35:,5].tolist()
        self.Time=data.iloc[35:,6].tolist()
        if print_run_time:
            end_time=time.time()
            print('Run Time:',end_time-start_time)

def remove_rod_force(file_path: string):
    '''
    This function is for later manual excel analysis.
    This function calculates Force w/o rodforce and stores the result as a new column.
    The new file will directly overwrite the old file.
    The color and font type information may be lost after this function, because 
    pandas's Dataframe object does not include these information when converting. 
    '''
    data=pd.read_excel(file_path)
    rod_force=data.iloc[10,1]
    print(rod_force)
    force=data.iloc[35:,0].tolist()
    force=list(x-rod_force for x in force)
    force[0:0]=['Force w/o rod force','lbs']
    force[0:0]=[np.nan]*33
    data.insert(7,np.nan,force)
    data.to_excel(file_path,header=True,index_label=False,index=False)
    
def find_local_max(data: list, threshold, windows: int, print_run_time=False):
    '''
    This function will go through all points inside the input list.
    threshold:
    Before the dyno starts to move, the load cell is already recording, therefore many 
    points is collected then. Among them is there small bumps, which can be falsely recognized.
    the threshold parameter is to filter out these fake local_max.
    windows:
    This parameter aimed to eliminate fake local_max found from noisy signals.
    The unit of the parameter is in points, therefore windows size should be varied with different testing velocity.
    Function will make sure there is no other points that is larger than current point inside the window.
    For example, if window size is 2. The function will check previous and later 2 points.
    '''
    if print_run_time:
        start=time.time()
    result=[]
    zone=[x for x in range(-windows,windows) if x!=0]
    for i in range(windows,len(data)-windows):
        local_max=True
        for j in zone:
            if data[i]<data[i+j]:
                local_max=False
                break
        if local_max and data[i]>threshold:
            result.append(i)
    if print_run_time:
        end=time.time()
        print('Run Time:',end-start)
    return result

def find_local_min(data: list, threshold, windows: int, print_run_time=False):
    '''
    This function will go through all points inside the input list.
    threshold:
    Before the dyno starts to move, the load cell is already recording, therefore many 
    points is collected then. Among them is there small bumps, which can be falsely recognized.
    the threshold parameter is to filter out these fake local_min.
    windows:
    This parameter aimed to eliminate fake local_min found from noisy signals.
    The unit of the parameter is in points, therefore windows size should be varied with different testing velocity.
    Function will make sure there is no other points that is larger than current point inside the window.
    For example, if window size is 2. The function will check previous and later 2 points.
    '''
    if print_run_time:
        start=time.time()
    result=[]
    zone=[x for x in range(-windows,windows) if x!=0]
    for i in range(windows,len(data)-windows):
        local_min=True
        for j in zone:
            if data[i]>data[i+j]:
                local_min=False
                break
        if local_min and -data[i]>threshold:
            result.append(i)
    if print_run_time:
        end=time.time()
        print('Run Time:',end-start)
    return result

def list_cal(A, B, oper):
    '''
    Just a simple tool to make calculation between lists or other iterable objects.
    oper:
    This parameter can equal to '+'/'-'/'*', other than that the function will conduct division.
    For minus and devision, A is always in the front.
    '''
    C=list()
    if oper=='+':
        for i in range(len(A)):
            C.append(A[i]+B[i])
    elif oper=='-':
        for i in range(len(A)):
            C.append(A[i]-B[i])
    elif oper=='*':
        for i in range(len(A)):
            C.append(A[i]*B[i])
    else:
        for i in range(len(A)):
            C.append(A[i]/B[i])
    return C

def remove_outlier(list_data: list, threshold: int):
    avg=sum(list_data)/len(list_data)
    std=stat.stdev(list_data)
    threshold=threshold*std
    return [x for x in list_data if abs(x-avg)<threshold]

def butter_lowpass_filter(data, cutoff, fs=2000, order=5):
    '''
    This function is for noisy velocity and force data.
    cutoff:
    Cutoff frequency.
    fs:
    Sample frequency.
    order:
    The order of the butterworth low pass filter. The bigger the order, the greater the phase shift.
    But with greater decade after cutoff frequency.
    '''
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = sig.butter(order, normal_cutoff, btype='low', analog=False)
    y = sig.lfilter(b, a, data)
    return y

def myfft(data: list, sample_freq=2000):
    '''
    This function helps users to determine how to set the cutoff freq. of low pass filter.
    sample_freq:
    Just sample frequency.
    '''
    N=len(data)
    T=1/sample_freq
    y=fft.fft(data)
    y=2.0/N * np.abs(y[0:N//2])
    x=fft.fftfreq(N, T)[:N//2]
    return x, y